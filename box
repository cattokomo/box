#!/usr/bin/env bash

declare -x utils_default_options_format="help:-h/--help"
utils.default_options_handler()
{
  declare command="$1"
  shift
  (( $1 )) && {
    declare -gx errmsg="$2"
    return 1
  }

  case "$2" in
    help) commands.help "$command"; return 30;;
  esac
}

utils.strip_options()
{
  declare args=("$@")
  for i in "${!args[@]}"; do
    declare arg="${args[$i]}"
    [[ "$arg" == -* ]] && unset "args[$i]"
    [[ "$arg" == -- ]] && break
  done
  echo "${args[@]}"
}
# shellcheck shell=bash

utils.extopts()
{
  declare callback="$1" format="$2 "
  shift
  shift

  declare -A options options_needargs
  while read -r -d " " fmt; do
    declare iden="${fmt%%:*}" body="${fmt#*:}"
    declare longopt="${body#*/}" shortopt="${body%/*}"
    declare passarg=0
    [[ "$fmt" == *: ]] && passarg=1
  
    [[ "$longopt" == "." ]] || options["$longopt"]+="$iden"
    [[ "$shortopt" == "." ]] || options["$shortopt"]+="$iden"
    (( passarg )) && options_needargs["$iden"]=1
  done <<<"$format"

  while (( $# )); do
    [[ "$1" == -* ]] || { shift; continue; }
    declare err=0 errmsg opt="$1" iden arg

    if [[ -z "${options[$opt]}" ]]; then
      err=1
      errmsg="invalid option: $opt"
    else
      iden="${options[$opt]}"
    fi

    if (( !err && options_needargs["$iden"] )); then
      shift
      arg="$1"
    fi

    if (( err )); then
      "$callback" 1 "$errmsg"
      return 1
    else
      "$callback" 0 "$iden" "$arg" || return "$?"
    fi
    shift
  done
}

__command_help="help"
__summary_help="Prints this message and subcommand usage."
__args_help=("[subcommand]")
__args_summary_help=("A subcommand to see it's usage.")
__options_help=("-h, --help")
__options_summary_help=("Prints usage of this subcommand.")
__help_options_format=""

commands.help_options_handler()
{
  utils.default_options_handler help "$@"
}

commands.help()
{
  if [[ -n "$errmsg" ]]; then
    declare opt="${errmsg##*' '}"
    {
      echo "Usage: ${0##*/} help [options] [subcommand]"
      echo
      echo "Error: unknown option \`$opt'"
    } >&2
    return 1
  fi

  declare summary command
  if (( !$# )); then
    echo "Usage: ${0##*/} <subcommand> [options] ..."
    echo
    echo "A Bash dependency manager."
    echo
    echo $'\e[1m━━━ Subcommands ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\e[m'

    while read -r var; do
      [[ "$var" == "declare -- __command_"* ]] || continue
      : "${var##*-- }"
      command="${_%%=*}"
      summary="__summary_${command##*_}"
      echo "  ${!command} "$'\e[1m↴\e[m\n    '"${!summary}"
    done <<<"$(declare -p)"

    echo
    echo "For more information, try add \`-h' flag to a subcommand or pass an subcommand to \`help'."
  elif [[ "$(type -t "commands.$1")" == "function" ]]; then
    summary="__summary_$1"
    declare -n args="__args_$1" args_summary="__args_summary_$1"
    declare -n options="__options_$1" options_summary="__options_summary_$1"

    echo "Usage: ${0##*/} $1 [options]${args[*]:+ ${args[*]}}"
    echo
    echo "${!summary}"
    echo

    if declare -p "__args_$1" >/dev/null 2>&1 && (( ${#args[@]} )); then
      echo $'\e[1m━━━ Arguments ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\e[m'
      for i in "${!args[@]}"; do
        declare arg="${args[$i]}"
        echo "  $arg "$'\e[1m↴\e[m\n    '"${args_summary[$i]}"
      done
      echo
    fi

    if declare -p "__options_$1" >/dev/null 2>&1 \
    && (( ${#options[@]} ))
    then
      echo $'\e[1m━━━ Options ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\e[m'
      for i in "${!options[@]}"; do
        declare opt="${options[$i]}"
        echo "  $opt "$'\e[1m↴\e[m\n    '"${options_summary[$i]}"
      done
    fi
  else
    {
      echo "Usage: ${0##*/} help [options] [subcommand]"
      echo
      echo "Error: unknown subcommand \`$1'"
    } >&2
    return 1
  fi
}
__command_install="install"
__summary_install="Installs dependencies from \`Boxfile.sh'."
__options_install=(
  "-v, --verbose"
  "-q, --quiet"
  "-f, --file"
)


(( $# )) || {
  commands.help >&2
  exit 1
}

declare command="$1"
shift
if [[ "$(type -t "commands.$command")" != "function" ]]; then
  {
    echo "Usage: ${0##*/} <subcommand> [options] ..."
    echo
    echo "Error: unknown subcommand \`$command'"
  } >&2
  exit 1
fi

declare command_options_format="__${command}_options_format"

# shellcheck disable=SC2154 # it's in ./utils/commands.sh
utils.extopts "commands.${command}_options_handler" "$utils_default_options_format${!command_options_format:+ ${!command_options_format}}" "$@"
(( $? == 30 )) && exit
# shellcheck disable=SC2046 # it's intended
set -- $(utils.strip_options "$@")
commands."$command" "$@"
exit "$?"
