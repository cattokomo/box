#!/usr/bin/env bash

declare -x utils_default_options_format="help:-h/--help"
utils.default_options_handler()
{
  declare command="$1"
  shift
  (( $1 )) && {
    declare -gx errmsg="$2"
    return 1
  }

  case "$2" in
    help) commands.help "$command"; return 30;;
  esac
}

utils.strip_options()
{
  declare args=("$@")
  for i in "${!args[@]}"; do
    declare arg="${args[$i]}"
    [[ "$arg" == -* ]] && unset "args[$i]"
    [[ "$arg" == -- ]] && break
  done
  echo "${args[@]}"
}

utils.has_command()
{
  command -v "$1" >/dev/null
}
# shellcheck shell=bash

utils.extopts()
{
  declare callback="$1" format="$2 "
  shift
  shift

  declare -A options_ options_needargs
  while read -r -d " " fmt; do
    declare iden="${fmt%%:*}" body="${fmt#*:}"
    declare longopt="${body#*/}" shortopt="${body%/*}"
    declare passarg=0
    [[ "$fmt" == *: ]] && passarg=1
  
    [[ "$longopt" == "." ]] || options_["$longopt"]+="$iden"
    [[ "$shortopt" == "." ]] || options_["$shortopt"]+="$iden"
    (( passarg )) && options_needargs["$iden"]=1
  done <<<"$format"

  while (( $# )); do
    [[ "$1" == -* ]] || { shift; continue; }
    declare err=0 errmsg opt="$1" iden arg

    if [[ -z "${options_[$opt]}" ]]; then
      err=1
      errmsg="invalid option: $opt"
    else
      iden="${options_[$opt]}"
    fi

    if (( !err && options_needargs["$iden"] )); then
      shift
      arg="$1"
    fi

    if (( err )); then
      "$callback" 1 "$errmsg"
      return 1
    else
      "$callback" 0 "$iden" "$arg" || return "$?"
    fi
    shift
  done
}

cmdinfo.help()
{
  summary="Prints this message and subcommand usage"
  args=("[subcommand]")
  args_summary=("A subcommand to see it's usage.")
  options=("-h, --help")
  options_summary=("Prints subcommand usage.")
  options_format=""
}

options_handler.help()
{
  utils.default_options_handler help "$@"
}

commands.help()
{
  if [[ -n "$errmsg" ]]; then
    declare opt="${errmsg##*' '}"
    {
      echo "Usage: ${0##*/} help [options] [subcommand]"
      echo
      echo "Error: unknown option \`$opt'"
    } >&2
    return 1
  fi

  declare summary command
  if (( !$# )); then
    echo "Usage: ${0##*/} <subcommand> [options] ..."
    echo
    echo "A Bash dependency manager."
    echo
    echo $'\e[1m━━━ Subcommands ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\e[m'

    while read -r cmd; do
      [[ "$cmd" == "declare -f commands."* ]] || continue
      : "${cmd##*-f commands.}"
      command="${_%%=*}"
      cmdinfo."$command"
      echo "  $command "$'\e[1m↴\e[m\n    '"$summary"
    done <<<"$(declare -pF)"

    echo
    echo "For more information, try add \`-h' flag to a subcommand or pass an subcommand to \`help'."
  elif [[ "$(type -t "commands.$1")" == "function" ]]; then
    cmdinfo."$1"
    echo "Usage: ${0##*/} $1 [options]${args[*]:+ ${args[*]}}"
    echo
    echo "${summary}"
    echo

    if (( ${#args[@]} )); then
      echo $'\e[1m━━━ Arguments ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\e[m'
      for i in "${!args[@]}"; do
        declare arg="${args[$i]}"
        echo "  $arg "$'\e[1m↴\e[m\n    '"${args_summary[$i]}"
      done
      echo
    fi

    if (( ${#options[@]} )); then
      echo $'\e[1m━━━ Options ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\e[m'
      for i in "${!options[@]}"; do
        declare opt="${options[$i]}"
        echo "  $opt "$'\e[1m↴\e[m\n    '"${options_summary[$i]}"
      done
    fi
  else
    {
      echo "Usage: ${0##*/} help [options] [subcommand]"
      echo
      echo "Error: unknown subcommand \`$1'"
    } >&2
    return 1
  fi
}
__command_install="install"
__summary_install="Installs dependencies from \`Boxfile.sh'."
__options_install=(
  "-v, --verbose"
  "-q, --quiet"
  "-f, --file"
)



core.resolver.temp_dir()
{
  echo "./.box/temp/$1"
}

core.resolver.parse_boxfile()
{
  declare oldpath="$PATH"
  export PATH=""
  enable -n command exec trap

  declare -ga deps
  declare i=1
  
  dependency()
  {
    declare depname="dep_$i"
    (( i++ ))

    declare -gA "$depname"
    deps+=("$depname")
    [[ "$(declare -p current_dep 2>/dev/null)" == "declare -n"* ]] &&
      unset -n current_dep

    declare -gn current_dep="$depname"
    current_dep+=(
      [dependency]="$1"
    )
  }
  
  src()
  {
    declare type="$1"
    shift
    case "$type" in
      git|tarball)
        current_dep+=(
          [srctype]="$type"
          [srcurl]="$1"
        )
        ;;
      external)
        current_dep+=(
          [srctype]=external
        )
        ;;
    esac
  }

  source ./boxfile.sh
  
  enable command exec trap
  unset -f dependency src
  unset -n current_dep
  unset current_dep
  export PATH="$oldpath"
}


(( $# )) || {
  commands.help >&2
  exit 1
}

declare command="$1"
shift
if [[ "$(type -t "commands.$command")" != "function" ]]; then
  {
    echo "Usage: ${0##*/} <subcommand> [options] ..."
    echo
    echo "Error: unknown subcommand \`$command'"
  } >&2
  exit 1
fi

cmdinfo."$command"

# shellcheck disable=SC2154 # it's in ./utils/commands.sh
utils.extopts "options_handler.${command}" "$utils_default_options_format${options_format:+ $options_format}" "$@"
(( $? == 30 )) && exit

# shellcheck disable=SC2046 # it's intended
set -- $(utils.strip_options "$@")

commands."$command" "$@"
